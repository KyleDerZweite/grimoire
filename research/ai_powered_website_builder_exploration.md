# **The Autonomous Stack: A Comprehensive Analysis of Open Source, Self-Hosted AI Website Builders Utilizing Astro and React**

## **1. Introduction: The Paradigm Shift to Intent-Based Engineering**

The software development industry is currently navigating a pivotal transition, moving from imperative coding paradigms—where developers manually author syntax—to intent-based engineering, colloquially known as "vibe coding." This shift is characterized by the abstraction of implementation details through the use of Generative AI, allowing architects and developers to focus on high-level system behavior, user experience, and architectural integrity. In this new era, the "website builder" is no longer a drag-and-drop interface constrained by vendor templates, but an intelligent, text-to-code agent capable of scaffolding production-grade applications in modern frameworks like **Astro** and **React**.

This report provides an exhaustive technical analysis of the emerging ecosystem of open-source AI website builders. Unlike proprietary SaaS solutions such as v0.dev or Bolt.new, the open-source sector prioritizes data sovereignty, infrastructure independence, and the "Bring Your Own LLM" (BYO-LLM) model. We examine the intricate architectures of tools like **Bolt.diy**, **OpenBolt**, and **Webstudio**, evaluating their capacity to generate, refine, and deploy complex web applications.

A specific focus is placed on the technical intersection of **Astro**—a content-focused framework leveraging island architecture—and **React**, the dominant library for interactive user interfaces. Furthermore, we scrutinize the operational realities of **self-hosting** these agents. The analysis covers Docker containerization, networking intricacies within WebContainer environments, and the hardware requirements for running local Large Language Models (LLMs) such as DeepSeek and Qwen. This document serves as a definitive resource for technical decision-makers seeking to implement autonomous, secure, and cost-effective development environments.

## ---

**2. The Evolution of Web Construction: From CMS to AI Agents**

To understand the significance of current open-source AI builders, one must contextualize them within the broader evolutionary arc of web development tools. The trajectory has consistently moved towards higher abstraction layers, yet primarily at the cost of code ownership and flexibility. The current generation of AI tools breaks this trend by restoring code access while maximizing abstraction.

### **2.1 The Legacy of Visual Abstraction**

For decades, the market was bifurcated. On one side stood the Content Management Systems (CMS) like WordPress and Joomla 1, offering extensibility but requiring server-side maintenance. On the other were visual builders like Wix and Squarespace 2, which offered ease of use but locked users into proprietary "walled gardens." These platforms utilized a "visual-to-database" model where the user's design choices were stored as metadata, rendered dynamically by a monolithic engine. The code was never truly exposed or editable.

The "Low-Code/No-Code" movement attempted to bridge this gap. Platforms like Webflow allowed for visual manipulation of HTML/CSS primitives, but the resulting code was often bloated or difficult to export and host independently. The critical limitation remained: the tool was the source of truth, not the codebase.

### **2.2 The Generative AI Disruption**

The advent of Large Language Models (LLMs) trained on vast repositories of public code (GitHub, StackOverflow) has fundamentally altered this equation. New tools operate on a "text-to-code" basis. The user provides a natural language prompt, and the AI generates standard, standards-compliant code.

This represents a return to the "code-as-source-of-truth" philosophy, but with the accessibility of a visual builder. Tools like **Bolt.diy** and **vx.dev** do not store metadata; they generate actual file systems containing .astro, .jsx, and .css files.3 This distinction is crucial for professional adoption. It means that an application generated by an AI builder can be ejected, version-controlled in Git, and maintained manually by a human developer without dependency on the original generation tool.

### **2.3 The Rise of "Vibe Coding"**

The term "vibe coding" 5 has emerged to describe a workflow where the developer's primary role shifts from writing syntax to directing an AI agent. In this workflow, the developer is responsible for the "vibe"—the aesthetic, functionality, and user journey—while the AI manages the boilerplate, typing, and component integration.

This methodology is particularly potent when combined with frameworks like Astro. Astro's "zero-JavaScript-by-default" philosophy aligns well with AI generation, as it enforces a clear separation between static content and dynamic interactivity. An AI agent can effectively structure the static shell using Astro's component syntax while isolating complex logic within React islands, reducing the cognitive load on the human reviewer.

## ---

**3. The Open Source Landscape: Taxonomy and Architecture**

The ecosystem of open-source AI website builders is rapidly diversifying. We can categorize the current market leaders based on their underlying architecture and interaction model.

### **3.1 Taxonomy of AI Builders**

| Category | Primary Mechanism | Representative Tools | Key Characteristics |
| :---- | :---- | :---- | :---- |
| **Browser-Native Agents** | WebContainers | **Bolt.diy**, **OpenBolt.dev** | Runs Node.js in the browser; full-stack capabilities; ephemeral file systems. |
| **Visual-AI Hybrids** | Visual Editor \+ AI | **Webstudio** | Drag-and-drop interface with AI "inception" for component generation; Remix-based. |
| **Prompt-to-UI Generators** | Component Scaffolding | **vx.dev**, **Rapidpages** | Generates specific UI components (shadcn/Tailwind) rather than full apps; React-centric. |
| **Config-Based Generators** | JSON/YAML Config | **Shakō**, **LittleLink** | Not generative AI, but structural generation based on config; often targets Link-in-Bio use cases. |

### **3.2 Deep Dive: The Bolt.diy Architecture**

**Bolt.diy** 3 stands as the flagship open-source project in this domain. A community-maintained fork of StackBlitz's commercial Bolt.new, it represents a sophisticated application of browser-based computing.

#### **3.2.1 The WebContainer Core**

The defining technology behind Bolt.diy is the **WebContainer API**.8 Unlike traditional cloud IDEs (like GitHub Codespaces) that stream a video feed of a remote Linux virtual machine, WebContainers execute the Node.js runtime entirely within the client's browser (specifically Chrome-based browsers).

* **Mechanism**: The browser utilizes Service Workers and SharedArrayBuffer to create a virtual file system and execute Node.js binaries via WebAssembly (Wasm).  
* **Networking**: The container includes a virtualized TCP/IP stack. When a user runs npm run dev in Bolt.diy, the server starts inside the browser tab, binding to a virtual port (e.g., 5173). The application then proxies requests to this virtual port, displaying the result in a live preview iframe.  
* **Implications for Self-Hosting**: This architecture profoundly impacts self-hosting. The "server" running the Docker container for Bolt.diy essentially serves the *frontend* of the builder. The actual "development environment" is downloaded and executed on the client's machine. This offloads compute costs from the host server to the user's device but complicates networking with local resources (discussed in Chapter 6).

#### **3.2.2 The LLM Abstraction Layer**

Bolt.diy decouples the development environment from the intelligence layer. It utilizes the **Vercel AI SDK** to provide a provider-agnostic interface.7

* **Provider Support**: It supports over 19 providers, including OpenAI, Anthropic, Google Gemini, and Mistral.  
* **Local Integration**: Through standardized API interfaces (often mimicking OpenAI's chat completions API), Bolt.diy can connect to local inference servers like **Ollama** or **LM Studio**. This allows for a completely offline, air-gapped development workflow, provided the local hardware is sufficient.

### **3.3 The Visual Alternative: Webstudio**

**Webstudio** 10 approaches the problem from a designer's perspective. It functions as an open-source alternative to Webflow but architectures its output on **Remix** (a React meta-framework).

* **Inception AI**: Webstudio's AI feature, dubbed "Inception" 10, focuses on generating the visual structure. A user might prompt "A pricing section with three tiers," and the AI constructs the visual tree with appropriate CSS tokens.  
* **CSS-First Philosophy**: Unlike Bolt, which generates raw code files, Webstudio abstracts CSS into a token system. This ensures design consistency and prevents the "spaghetti CSS" often produced by raw LLM generation.  
* **Deployment**: Webstudio projects are designed to be deployed to edge networks like Cloudflare Workers, leveraging the distributed nature of Remix.

### **3.4 Component Generators: vx.dev**

**vx.dev** 11 operates as an open-source clone of Vercel's v0.dev. Its scope is narrower than Bolt.diy.

* **Focus**: It generates individual React components using **shadcn/ui** and **Tailwind CSS**.  
* **Workflow**: Users prompt for a specific UI element (e.g., "A dashboard card with a chart"), and the tool returns the JSX and Tailwind classes.  
* **Integration**: It is intended to be used alongside a main editor (like VS Code), where the developer copies the generated code into their project. It lacks the full project scaffolding capabilities of Bolt.diy.

## ---

**4. Framework Synergy: Astro and React in the AI Era**

The user's requirement specifically highlights **Astro** and **React**. These two technologies have become the "gold standard" for modern content-rich applications. AI builders exhibit specific behaviors and capabilities when targeting this stack.

### **4.1 Astro: The Content-First Foundation**

Astro is increasingly favored by AI agents for generating static sites due to its clean separation of concerns.

#### **4.1.1 Generative Advantages of Astro**

* **File Structure Clarity**: Astro's file-based routing and .astro single-file component syntax (HTML \+ CSS \+ JS) are highly structured. This structure reduces the "context window" burden on LLMs compared to complex React setups with separate CSS modules and routing files.  
* **Type Safety**: Modern prompts often enforce TypeScript in Astro.12 The explicit interface definitions in Astro content collections help AI agents "hallucinate" less by creating rigid schemas for data.  
* **Performance by Default**: AI-generated code is notoriously unoptimized. Astro's "Zero JS" default acts as a guardrail, ensuring that even if the AI generates inefficient JavaScript, it won't impact the initial load time unless explicitly hydrated.

#### **4.1.2 Bolt.diy and Astro Templates**

Bolt.diy includes dedicated templates for Astro.3 When a user initiates a project with "Build an Astro blog," the system:

1. Clones the official Astro starter template into the WebContainer.  
2. Installs dependencies (npm install).  
3. Configures astro.config.mjs with necessary integrations (Tailwind, React).

Research indicates that early versions of WebContainers struggled with Astro's complex build process (specifically Vite's SSR handling).13 However, recent updates to both Astro (v5/v6) and the WebContainer API have resolved most compatibility issues, enabling features like **Content Layer** and **Server Islands** to run directly in the browser.14

### **4.2 React: The Interactive Engine**

React remains the lingua franca of AI coding models due to the sheer volume of React code in their training datasets.

#### **4.2.1 The Shadcn/Tailwind Dominance**

Open-source builders like Bolt.diy and vx.dev heavily favor the **shadcn/ui** library combined with **Tailwind CSS**.11

* **Reasoning**: Shadcn provides accessible, unstyled components that copy-paste directly into the project. This avoids the need for the AI to manage a complex node\_modules dependency tree for UI components. The AI simply writes the component code into the src/components/ui folder.  
* **Styling**: Tailwind allows the AI to apply styling via string manipulation (className="p-4 bg-red-500"), which LLMs excel at, rather than managing cascading stylesheets.

### **4.3 The Hybrid Model: Astro Islands**

The true power of this stack lies in **Astro Islands**. AI builders can effectively implement this pattern by:

1. **Scaffolding the Shell**: Generating the global layout, header, and footer in .astro files.  
2. **Generating Components**: Creating complex interactive widgets (calculators, forms, dashboards) as .jsx React components.  
3. **Integration**: Writing the hydration directive (client:load, client:visible) in the Astro parent file.

**Case Example from Analysis**:

A user prompts Bolt.diy to "Create a Link-in-Bio site." The agent generates:

* src/pages/index.astro: The main container using a grid layout.  
* src/components/LinkCard.astro: A static component for simple links (fast load).  
* src/components/ContactForm.jsx: A React component for the contact modal, hydrated only when the user clicks "Contact."  
  This demonstrates the "Right Tool for the Right Job" philosophy, automated by AI.

## ---

**5. Infrastructure: The Guide to Self-Hosting**

Self-hosting an AI builder provides privacy and cost benefits but introduces significant infrastructure complexity. This section details the deployment of **Bolt.diy** using Docker.

### **5.1 Docker Container Architecture**

The Bolt.diy repository provides a Dockerfile and docker-compose.yaml optimized for production deployment.16

#### **5.1.1 The Dockerfile**

The build process typically involves:

1. **Base Image**: node:18-alpine or node:20-alpine (Node 18+ is a strict requirement for WebContainers).  
2. **Build Stage**: Installs dependencies via pnpm and runs the Remix build command.  
3. **Runtime Stage**: Serves the built Remix app using a lightweight server.

#### **5.1.2 Docker Compose Configuration**

A robust docker-compose.yaml is essential for orchestrating the application and its environment variables.

**Configuration Example:**

YAML

version: '3.8'

services:  
  bolt-diy:  
    container\_name: bolt-diy  
    image: stackblitz-labs/bolt.diy:latest  
    build:  
      context:.  
      target: bolt-ai-production  
    ports:  
      \- "5173:5173"  
    environment:  
      \- NODE\_ENV=production  
      \- PORT=5173  
      \# API Keys for Cloud Providers (Optional)  
      \- OPENAI\_API\_KEY=${OPENAI\_API\_KEY}  
      \- ANTHROPIC\_API\_KEY=${ANTHROPIC\_API\_KEY}  
      \# Local LLM Configuration  
      \- OLLAMA\_API\_BASE\_URL=http://host.docker.internal:11434  
    volumes:  
      \-./bolt-data:/app/data  
    extra\_hosts:  
      \- "host.docker.internal:host-gateway"  
    restart: unless-stopped

  \# Optional: Nginx for SSL Termination  
  nginx:  
    image: nginx:alpine  
    ports:  
      \- "80:80"  
      \- "443:443"  
    volumes:  
      \-./nginx.conf:/etc/nginx/conf.d/default.conf  
      \-./certs:/etc/nginx/certs  
    depends\_on:  
      \- bolt-diy

### **5.2 Networking Intricacies**

The most common failure point in self-hosting is networking.

#### **5.2.1 The "Host Gateway" Pattern**

When using local LLMs (like Ollama) running on the host machine (not inside Docker), the Bolt container needs to access the host's network.

* **Problem**: localhost inside the container refers to the container itself, not the host.  
* **Solution**: The extra\_hosts entry "host.docker.internal:host-gateway" maps the host's IP to the hostname host.docker.internal. The OLLAMA\_API\_BASE\_URL environment variable must then use this hostname.16

#### **5.2.2 WebContainer Sandbox Limitations**

Crucially, the *development server* (the generated Astro app) runs inside the user's browser.

* **Scenario**: You want your generated Astro app to fetch data from a local API running on your server at api.myserver.local.  
* **Constraint**: The browser blocks requests to local/private IPs from public contexts (Mixed Content/CORS).  
* **Workaround**: You must expose your local API via a reverse proxy with valid SSL (HTTPS) to allow the browser-based WebContainer to communicate with it.

### **5.3 Platform-Specific Deployments**

* **Coolify**: A self-hosted PaaS alternative to Vercel. Snippets confirm successful deployments of Bolt.diy on Coolify using the "Docker Compose Empty" resource type.18 This manages SSL and domain routing automatically.  
* **Railway**: While a cloud service, Railway offers a "Deploy Bolt" template that simplifies the environment variable injection and persistent volume claims.19

## ---

**6. The Intelligence Layer: Integrating Local and Cloud LLMs**

The "brain" of the self-hosted builder is the Large Language Model. Users have the choice between high-intelligence cloud models and private local models.

### **6.1 Cloud Providers**

Bolt.diy supports the **Vercel AI SDK**, enabling integration with:

* **Anthropic Claude 3.5 Sonnet**: Currently regarded as the state-of-the-art for coding tasks due to its superior reasoning and context window.3  
* **OpenAI GPT-4o**: Highly capable, particularly for generating React component logic.  
* **Google Gemini 1.5 Pro**: Offers a massive context window (up to 2M tokens), allowing the entire codebase to be analyzed for refactoring.

### **6.2 Local LLMs: The Ollama Integration**

For a fully air-gapped solution, integrating **Ollama** is the standard path.

#### **6.2.1 Recommended Models**

Based on performance benchmarks referenced in the research 3:

* **DeepSeek-Coder V3**: A specialized coding model that rivals GPT-4. It is open weights but requires significant hardware.  
* **Qwen 2.5 Coder (32B)**: Offers an excellent balance of performance and resource usage. It is capable of understanding complex Astro/React patterns.  
* **Llama 3 (70B)**: A strong generalist model, though often more verbose than specialized coding models.

#### **6.2.2 Hardware Requirements for Local Inference**

Running these models locally requires substantial GPU resources.

| Model Size | Minimum VRAM | Recommended GPU | Notes |
| :---- | :---- | :---- | :---- |
| **7B \- 8B** | 6 GB | RTX 3060 / 4060 | Good for simple components; struggles with full-app context. |
| **14B \- 32B** | 16 GB \- 24 GB | RTX 3090 / 4090 | Sweet spot for serious coding assistance. |
| **70B+** | 48 GB+ | 2x RTX 3090 / A6000 | Required for "GPT-4 class" reasoning locally. |

*Quantization*: Most users run "quantized" models (e.g., Q4\_K\_M) to fit larger models into smaller VRAM footprints with minimal accuracy loss.

## ---

**7. Prompt Engineering: System Prompts and Rules**

The quality of the output from an open-source builder is heavily dependent on the "System Prompt"—the initial set of instructions given to the LLM. Unlike closed systems, open-source tools allow users to modify this prompt.

### **7.1 The "Cursor Rules" Standard**

The concept of .cursorrules has popularized the idea of project-specific AI instructions. These rules can be adapted into the system prompt of Bolt.diy.12

### **7.2 Optimal System Prompt for Astro/React**

To maximize success with Astro and React, the system prompt should enforce specific architectural constraints.

**Drafting a Robust System Prompt:**

"You are an expert full-stack developer specializing in Astro and React.

1. **Framework Preference**: Always use Astro for the site shell (.astro files). Use React (.jsx) solely for interactive islands.  
2. **Styling**: Use Tailwind CSS for all styling. Do not create CSS modules or standard CSS files unless absolutely necessary. Use clsx or tailwind-merge for class logic.  
3. **Integration**: When adding libraries, assume the environment is a WebContainer. Use npm install and configure astro.config.mjs manually if the astro add command is unstable in the current shell.  
4. **Performance**: Prioritize Core Web Vitals. Use the \<Image /\> component from astro:assets.  
5. **Data Fetching**: Use getStaticPaths for dynamic routes. For client-side fetching in React, use SWR or TanStack Query."

### **7.3 Context Management**

A critical challenge in "text-to-code" is the limited context window.

* **Strategy**: Bolt.diy manages this by sending a "summary" of the file system to the LLM.  
* **Optimization**: Users should use the .bolt/ignore file (similar to .gitignore) to prevent the AI from wasting tokens reading node\_modules or build artifacts, ensuring the context window is reserved for source code.22

## ---

**8. Case Study: Building a Self-Hosted Link-in-Bio Platform**

To demonstrate the practical application of this stack, we walk through the generation of a **Link-in-Bio** clone (similar to Linktree), a requirement found in the research snippets (referencing **Shakō** and **LinkStack** 23).

### **8.1 Concept vs. Configuration**

While tools like **LinkStack** exist as pre-built PHP applications that one configures 23, our goal is to *generate* a custom version using **Bolt.diy**. This allows for infinite customization (e.g., "Add a Spotify player" or "Fetch my latest GitHub commits").

### **8.2 Execution Steps using Bolt.diy**

**Step 1: The Prompt**

"Build a responsive Link-in-Bio profile page using Astro. The data (name, avatar, links) should be stored in a src/data/profile.json file so it is easy to edit. Use Tailwind CSS for a 'glassmorphism' dark theme. Include a contact button that opens a React modal dialog."

**Step 2: Generation Analysis**

* **File Structure**:  
  * src/layouts/Layout.astro: Handles the \<head\>, meta tags, and global Tailwind directives.  
  * src/pages/index.astro: Fetches data from profile.json and maps over the links.  
  * src/components/ContactModal.jsx: A React component using useState for visibility and framer-motion for animations.  
* **Hydration**: The AI correctly identifies that the modal needs interactivity and adds the client directive:  
  Code-Snippet  
  \<ContactModal client:idle /\>

  *Insight*: Using client:idle instead of client:load improves the PageSpeed score, a nuance a well-tuned system prompt can enforce.

**Step 3: Customization**

Because this is code, not a config file, the developer can now prompt: "Fetch my latest 3 repos from the GitHub API and display them below the links." The AI modifies index.astro to perform a server-side fetch() at build time, maintaining the static nature of the site while adding dynamic data.

## ---

**9. Security and Enterprise Governance**

Adopting open-source AI builders in a professional environment requires addressing specific security risks.

### **9.1 Arbitrary Code Execution**

The nature of these tools is that they execute code generated by an LLM.

* **Risk**: An LLM could hallucinate (or be prompt-injected to produce) malicious code, such as a script that exfiltrates environment variables to an external server.  
* **Mitigation**:  
  1. **Sandboxing**: WebContainers provide a strong sandbox. Node.js processes cannot access the host machine's file system, only the virtual file system in the browser tab.  
  2. **Review**: The "Diff View" in Bolt.diy is critical. Developers must review code changes before accepting them.

### **9.2 Data Leakage with Cloud LLMs**

* **Risk**: Sending proprietary code or business logic to OpenAI/Anthropic.  
* **Mitigation**: This is the primary driver for self-hosting with **Ollama**. By using a local Qwen or DeepSeek model, the data never leaves the local network, ensuring complete confidentiality.

### **9.3 Persistence and Backups**

WebContainer file systems are ephemeral.

* **Risk**: Closing the browser tab without syncing results in data loss.  
* **Solution**: Enterprise deployments should enforce Git integration. Bolt.diy can be configured to auto-commit to a Gitea or GitHub repository, treating the browser environment as a temporary workspace rather than permanent storage.3

## ---

**10. Future Outlook: The Road to Autonomous Development**

The trajectory of open-source AI website builders points toward increasing autonomy.

### **10.1 From Assistants to Agents**

Current tools like Bolt.diy are "assistants"—they wait for user prompts. The next generation (referenced as "Agent Architecture" in Bolt's roadmap 7) will be capable of multi-step reasoning: "Update dependencies, run tests, fix any errors, and deploy."

### **10.2 Server-Side WebContainers**

While browser-based WebContainers are revolutionary, they are resource-constrained (limited by browser memory allocation). Future open-source projects may leverage server-side container orchestration (similar to GitHub Codespaces but self-hosted) to allow for heavier workloads, such as compiling Rust or running large databases, while maintaining the AI interface.

### **10.3 Conclusion**

For the organization seeking a **self-hosted**, **text-to-code** solution for **Astro** and **React**, **Bolt.diy** currently represents the state of the art. When coupled with a robust Docker infrastructure and high-performance local LLMs, it offers a development experience that rivals proprietary SaaS platforms while preserving the essential freedoms of open-source software. The combination of Astro's performance and React's interactivity, orchestrated by AI, creates a powerful paradigm where the speed of development is limited only by the speed of thought.

### ---

**Data Appendix: Feature Comparison of Self-Hosted Tools**

| Feature | Bolt.diy | OpenBolt | Webstudio | Shakō |
| :---- | :---- | :---- | :---- | :---- |
| **Primary Output** | Full-Stack App | Full-Stack App | Remix App | Static Site |
| **Astro Support** | **High** (Templates) | **High** | N/A | **Native** |
| **React Support** | **High** | **High** | **Native** | **High** |
| **Self-Hosting** | Docker Compose | Docker | Docker (Complex) | Static / Docker |
| **Local LLM Support** | Yes (Ollama) | Yes | No | N/A |
| **Mechanism** | WebContainer | WebContainer | Visual Builder | Config File |
| **License** | MIT | MIT | AGPL-3.0 | MIT |

3

#### **Referenzen**

1. Top 10 Open Source Alternatives to Carrd in 2025: A Comprehensive Comparison, Zugriff am Januar 31, 2026, [https://www.femaleswitch.com/directories/tpost/z3oio78vl1-top-10-open-source-alternatives-to-carrd](https://www.femaleswitch.com/directories/tpost/z3oio78vl1-top-10-open-source-alternatives-to-carrd)  
2. Open Source AI Website Builder: Create Stunning Sites Effortlessly, Zugriff am Januar 31, 2026, [https://wowslider.com/website-builder/open-source-ai-website-builder.html](https://wowslider.com/website-builder/open-source-ai-website-builder.html)  
3. Frequently Asked Questions (FAQ) \- bolt.diy Docs \- GitHub Pages, Zugriff am Januar 31, 2026, [https://stackblitz-labs.github.io/bolt.diy/FAQ/](https://stackblitz-labs.github.io/bolt.diy/FAQ/)  
4. Can't connect to other containers inside docker network, Zugriff am Januar 31, 2026, [https://forums.docker.com/t/cant-connect-to-other-containers-inside-docker-network/66512](https://forums.docker.com/t/cant-connect-to-other-containers-inside-docker-network/66512)  
5. Vibe Coding: Create a Static Website with Astro, Tailwind and Markdown for Content, Zugriff am Januar 31, 2026, [https://www.youtube.com/watch?v=cOc1xrJhglA](https://www.youtube.com/watch?v=cOc1xrJhglA)  
6. Cursor 2.0 vibe-coding competition portfolio website: 5 Models duke it out, Zugriff am Januar 31, 2026, [https://medium.com/@raj.pulapakura/cursor-2-0-vibe-coding-competition-portfolio-website-5-models-duke-it-out-005d2b9177b3](https://medium.com/@raj.pulapakura/cursor-2-0-vibe-coding-competition-portfolio-website-5-models-duke-it-out-005d2b9177b3)  
7. stackblitz-labs/bolt.diy: Prompt, run, edit, and deploy full-stack web applications using any LLM you want\! \- GitHub, Zugriff am Januar 31, 2026, [https://github.com/stackblitz-labs/bolt.diy](https://github.com/stackblitz-labs/bolt.diy)  
8. WebContainers \- Dev environments. In your web app. | WebContainers, Zugriff am Januar 31, 2026, [https://webcontainers.io/](https://webcontainers.io/)  
9. bolt.diy Docs \- GitHub Pages, Zugriff am Januar 31, 2026, [https://stackblitz-labs.github.io/bolt.diy/](https://stackblitz-labs.github.io/bolt.diy/)  
10. Webstudio — Advanced Open Source Website Builder, Zugriff am Januar 31, 2026, [https://webstudio.is/](https://webstudio.is/)  
11. dakouan18/vx.dev: An open-source alternative to v0.dev ... \- GitHub, Zugriff am Januar 31, 2026, [https://github.com/dakouan18/vx.dev](https://github.com/dakouan18/vx.dev)  
12. Astro Cursor Rules rule by Mathieu de Gouville \- Cursor Directory, Zugriff am Januar 31, 2026, [https://cursor.directory/astro-tailwind-cursor-rules](https://cursor.directory/astro-tailwind-cursor-rules)  
13. Announcing WebContainers Astro support\! \- StackBlitz Blog, Zugriff am Januar 31, 2026, [https://blog.stackblitz.com/posts/astro-support/](https://blog.stackblitz.com/posts/astro-support/)  
14. Astro 6 Beta, Zugriff am Januar 31, 2026, [https://astro.build/blog/astro-6-beta/](https://astro.build/blog/astro-6-beta/)  
15. I've built a site to generate UI from prompts/images : r/tailwindcss \- Reddit, Zugriff am Januar 31, 2026, [https://www.reddit.com/r/tailwindcss/comments/1e80qun/ive\_built\_a\_site\_to\_generate\_ui\_from\_promptsimages/](https://www.reddit.com/r/tailwindcss/comments/1e80qun/ive_built_a_site_to_generate_ui_from_promptsimages/)  
16. bolt.diy/docker-compose.yaml at main · stackblitz-labs/bolt.diy · GitHub, Zugriff am Januar 31, 2026, [https://github.com/stackblitz-labs/bolt.diy/blob/main/docker-compose.yaml](https://github.com/stackblitz-labs/bolt.diy/blob/main/docker-compose.yaml)  
17. How to install and self-host bolt.diy ? : r/selfhosted \- Reddit, Zugriff am Januar 31, 2026, [https://www.reddit.com/r/selfhosted/comments/1jwrrnp/how\_to\_install\_and\_selfhost\_boltdiy/](https://www.reddit.com/r/selfhosted/comments/1jwrrnp/how_to_install_and_selfhost_boltdiy/)  
18. Deploy Bolt.diy on Coolify: A Real-World Docker Compose Guide \- stuartmason \- Stu Mason, Zugriff am Januar 31, 2026, [https://stuartmason.co.uk/posts/running-boltdiy-on-coolify](https://stuartmason.co.uk/posts/running-boltdiy-on-coolify)  
19. Deploy Bolt DIY | Railway, Zugriff am Januar 31, 2026, [https://railway.com/deploy/bolt](https://railway.com/deploy/bolt)  
20. How to Use Bolt.new for FREE with Local LLMs (And NO Rate Limits) \- YouTube, Zugriff am Januar 31, 2026, [https://www.youtube.com/watch?v=8ommGcs\_-VU](https://www.youtube.com/watch?v=8ommGcs_-VU)  
21. JavaScript Astro Tailwind CSS .cursorrules prompt file \- GitHub, Zugriff am Januar 31, 2026, [https://github.com/PatrickJS/awesome-cursorrules/blob/main/rules/javascript-astro-tailwind-css-cursorrules-prompt-f/README.md](https://github.com/PatrickJS/awesome-cursorrules/blob/main/rules/javascript-astro-tailwind-css-cursorrules-prompt-f/README.md)  
22. I asked bolt.new how should I talk with "it" so I prepared this guide : r/boltnewbuilders \- Reddit, Zugriff am Januar 31, 2026, [https://www.reddit.com/r/boltnewbuilders/comments/1i4kik9/i\_asked\_boltnew\_how\_should\_i\_talk\_with\_it\_so\_i/](https://www.reddit.com/r/boltnewbuilders/comments/1i4kik9/i_asked_boltnew_how_should_i_talk_with_it_so_i/)  
23. LinkStack documentation: Overview of LinkStack, Zugriff am Januar 31, 2026, [https://docs.linkstack.org/](https://docs.linkstack.org/)  
24. keksiqc/shako: Self-hostable link-in-bio page \- GitHub, Zugriff am Januar 31, 2026, [https://github.com/keksiqc/shako](https://github.com/keksiqc/shako)  
25. 3 Modern Open-Source Tools for Building Websites \- Webstudio, Zugriff am Januar 31, 2026, [https://webstudio.is/blog/open-source-website-builder](https://webstudio.is/blog/open-source-website-builder)  
26. Kidjig/bolt.diy: Prompt, run, edit, and deploy full-stack web applications using any LLM you want\! \- GitHub, Zugriff am Januar 31, 2026, [https://github.com/Kidjig/bolt.diy](https://github.com/Kidjig/bolt.diy)